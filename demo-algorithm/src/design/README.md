### 设计模式
#####1.创建型模式 把对象的创建和使用相分离，这样使得两者能相对独立地变换
1).工厂模式 FactoryModel 使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品 静态static方法

2).抽象工厂 factory 多个工厂对应多个产品 多态的使用

3).生成器 builder 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 stringbulider append

4).原型模式/clone(copy) copy

5).单例  singleton DCL双重饿汉 DCL错误 [单例相关](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319214514210#0)

####2.结构性模式 如何组合各种对象以便获得更好、更灵活的结构
6).适配器 adapter 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 adapter

7).桥接 bridging 不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能(例子纯展示，实际一般直接使用car)

8).组合 node 组合模式（Composite）经常用于树形结构/层级结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。

9).装饰器 Decorator 运行期动态给某个对象的实例增加功能(和桥接不同在于，增强了原接口,并可以层层增强)

10).外观(中介） Facade 一个中介处理其他接口(例如网关)

11).享元 Flyweight 对象实例一经创建就不可变,直接向调用方返回一个共享的实例

12).代理 Proxy 实现类似adapter 代理以控制对这个对象的访问


####3.行为型模式 涉及算法和对象间的职责分配,描述一组对象应该如何协作来完成一个整体任务

13).责任链 Chain of Responsibility 是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止

14).命令 Command 把请求封装成一个命令，然后执行该命令

15).解释器 Interpreter 给定一个语言，定义它的文法的一种表示，并定义一个解释器,使用该表示来解释语言中的句子

16).迭代器 Iterator 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示 主要用作Collection上

17).中介 Mediator 调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合(android mvc 模式)

18).备忘录 Memento 捕获一个对象的内部状态，以便在将来的某个时候恢复此状态

19).观察者 Observer(发布-订阅模式) 一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

20).状态 State 允许一个对象在其内部状态改变时改变它的行为。(状态切换，if的扩展)

21).策略 Strategy 定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法

22).模板方法 Template 父类定义骨架(为防止骨架被改写，一般会设置final)，子类实现某些细节

23).访问者 Visitor 操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作(很像策略类型)
